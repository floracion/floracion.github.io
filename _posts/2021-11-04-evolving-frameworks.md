---
layout: post
title: 발전하는 프레임워크 (켄트 벡의 구현 패턴)
subtitle: Sangmin Lee
categories: OOP
tags: [OOP]
---

# Chapter 10. Evolving Frameworks
(발전하는 프레임워크)

이번 장에서는 프레임워크를 개발할 때 사용할 수 있는 구현 패턴에 대해 살펴본다.

먼저 프레임워크 개발의 어려운 점에 대해 살펴보고, 호환성을 깨뜨리는 업그레이드에 대한 영향을 어떻게 줄일 수 있는지,
어떻게 하면 그런 업그레이드를 피할 수 있는지 알아본다.

# 애플리케이션 수정 없이 프레임워크 수정하기

프레임워크를 개발할 때는 발전의 여지를 남겨 두면서도 충분히 단순해서 당장 사용할 수 있어야 한다.
또한 적용 범위를 확대할 여지를 남겨두면서도 당장 사용할 수 있을 정도의 적용성을 가져야 한다.

프레임워크를 유지보수하는 데 있어 근본적인 딜레마는 프레임워크를 지속적으로 발전시켜야 하지만, 기존 클라이언트 코드는 계속해서 동작하도록 해야 한다는 것이다.

이상적인 프레임워크 업그레이드는 기능 추가를 하면서도 기존 기능이 변함 없이 작동하게 해야 한다.

이런 여러 제약 사항들로 인해 프레임워크 개발은 애플리케이션 개발에 비해 위험성이 높고 비용이 많이 든다.

그러므로 다양한 구현 패턴을 살펴보면서 변화에 잘 대응할 수 있는 프레임워크를 개발하는 방법에 대해 살펴보자.

# 호환성 없는 업그레이드

프레임워크 업그레이드가 잠재적으로 클라이언트 코드를 동작하지 않게 할 수 있는 것은 사실이지만,
클라이언트 측면에서의 업그레이드 비용을 줄여주는 방법을 사용할 수는 있다.

예를 들어 어떤 기능을 더 이상 지원하지 않기(deprecation)로 하더라도 한두 번의 릴리즈에서 해당 기능을 계속 제공하면,
그 기간 동안 클라이언트는 새로운 API로 옮겨갈 수 있다.

기존 기능을 지원하지 않는 것은 두 개의 아키텍처를 유지하는 방법의 일종이다.

이런 병렬 아키텍처(parallel architecture)는 복잡도를 높이지만 업그레이드로 인한 문제점을 줄여준다.

자바 컬렉션 클래스는 병렬 아키텍처를 사용한다.

예를 들어, `ArrayList` 를 새로 릴리즈 했어도 기존 `Vector` 컬렉션을 제거하지 않고 유지하는 것과 같다.

패키지를 사용하면 점진적으로 클라이언트 코드를 업그레이드 할 수 있다.

새로운 클래스를 새로운 패키지에 넣을 때는 기존 클래스의 이름을 사용할 수 있다.

예를 들어, `org.junit.Assert` 를 `org.junit.improved.Assert` 로 업그레이드한다면 클라이언트는 간단히 `import` 문만 수정하면 된다.

이 절에서는 호환성이 없는 프레임워크 업그레이드를 하는 방법에 대해 알아봤다.

하지만 훨씬 바람직한 상황은 기존 클라이언트 코드에 영향을 주지 않으면서도 새로운 기능을 제공하는 호환성을 유지해주는 업그레이드이다.

이제 호환성을 유지하는 업그레이드 대해 알아보자.

# 호환성을 유지하는 업그레이드

클라이언트는 프레임워크의 변하지 않는 부분에만 의존적이어야 한다.

그러나 프레임워크의 확장과 변화는 예상할 수 없으므로 어떤 부분이 변화하지 않을지 미리 알 수 없다.

그러므로 가급적 눈에 보이는 세부 사항을 숨기고 변화하지 않을 가능성이 높은 부분만을 노출시킨다면 나중에 설계를 변경할 수 있는
유연성을 얻으면서도 유용한 기능을 제공할 수 있다.

자바로 작성된 대부분의 프레임워크는 클라이언트에 의해 생성되고 사용되고 확장되는 객체로 표현된다.

이 절에서는 어떻게 프레임워크를 표현해야 클라이언트가 필요한 기능을 찾아서 사용하면서도 프레임워크 개발자는 프레임워크를 계속 발전시킬 수 있는지 알아본다.

## 라이브러리 클래스

라이브러리 클래스는 복잡도를 높이지 않으면서도 미래에 대비할 수 있다.

제공하는 모든 기능을 간단한 파라미터를 취하는 함수로 표현함으로써, 클라이언트는 미래에 발생할 수정에 어느 정도 자유로울 수 있다.

`java.util.Collections` 클래스는 라이브러리 클래스를 통해 API를 제공하는 좋은 예시이다.

### [ `java.util.Collections` ]

```java
public class Collections {

	private Collections() {
  }

	public static <T extends Comparable<? super T>> void sort(List<T> list) { ... }

	...
}
```

- 인스턴스로 생성할 수 없으며 모든 메소드들이 정적 메소드로 구성되어 있다.

하지만, 라이브러리 클래스를 사용하는 클라이언트는 프레임워크로 보내는 데이터만 수정할 수 있을 뿐, 프레임워크에서 제공하는 로직을 변형시켜 사용할 수 없다.

## 객체

프레임워크는 클라이언트에게 유용하고 안정적이면서 프레임워크 개발자에게는 발전시키기 쉬워야 한다.

그러므로 프레임워크를 객체로 나타내려면 클라이언트가 프레임워크의 바뀌지 않을 것 같은 부분에만 의존적으로 코드를 작성하게 해야 한다.

이때 네 가지 이슈가 존재한다.

***사용 스타일***
: 클라이언트가 프레임워크 객체를 인스턴스화해서 사용할 것인가 아니면 확장시켜서(상속) 사용할 것인가?

***추상화***
: 클래스 수준의 세부 사항을 인터페이스로 나타낼 것인가 클래스로 나타낼 것인가? 세부 사항에 어떤 가시성을 사용할 것인가?

***생성***
: 어떻게 객체를 생성하는가?

***메소드***
: 메소드를 어떻게 구성하면 클라이언트에게는 유용성을, 프레임워크 개발자에게는 유연성을 제공할 수 있을까?

### 사용 스타일

프레임워크는 인스턴스화(instantiation), 설정(configuration), 구현(implementation)의 세 가지 주요 스타일을 지원한다.

가장 단순한 스타일은 **인스턴스화(instantiation)**이다. 예를 들어 만약 `ArrayList` 를 생성하고 싶다면 `new ArrayList<>()` 을 호출하면 된다.

```java
ArrayList<Object> objects = new ArrayList<>();
```

만약 클라이언트가 로직의 변형을 필요로 하지 않고 **데이터의 변형만을 필요로 하는 경우 인스턴스화를 사용하라.**

**설정(configuration)**은 인스턴스화보다 복잡하지만 좀더 유연하다.

클라이언트는 프레임워크 객체를 생성한 후 자신만의 객체를 프레임워크에 전달해서 프레임워크에서 사용되도록 한다.

예를 들어 `TreeSet` 를 생성할 때, 클라이언트에서 `Comparator` 를 인자로 넘겨 원소 사이의 정렬을 결정할 수 있다.

```java
Comparator<Book> byName = new Comparator<Book>() {
  public int compare(Book book1, Book book2) {
    return book1.getName().compareTo(book2.getName());
  }
};
TreeSet<Book> sorted = new TreeSet<>(byName);
```

클라이언트가 설정에서 제공하는 것 이상으로 많은 종류의 로직의 변형을 필요로 하는 경우, **구현(implementation)**에 의한 사용을 제공할 수 있다.

클라이언트 클래스가 프레임워크의 클래스나 인터페이스를 **확장(extends)** 이나 **구현(implement)**을 하게 되면, 클라이언트는 프레임워크의
어떤 로직이라도 사용할 수 있다.

앞에서 살펴본 `Comparator` 는 구현을 사용한 프레임워크의 간단한 예이다.

`byName` 은 컬렉션 프레임워크 추상화의 구현이다.

### 추상화

구현 스타일을 사용하려면 추상화된 개념을 **인터페이스**로 전달해야 하는지 **상위클래스**로 전달해야 하는지 결정해야 한다.

***인터페이스***

인터페이스를 클라이언트에게 제공할 때의 이점은 **세부 사항을 가급적 적게 드러낸다**는 것이다.

인터페이스가 바뀌지 않는다면 괜찮지만, 새로운 메서드를 인터페이스를 추가하는 경우 기존 인터페이스에 대한 모든 클라이언트 구현이 동작하지 않게 된다.

약간의 비용을 추가해서 인터페이스에 유연성을 부여한 형태로는 **버전 인터페이스**가 있다.

이는 기존 인터페이스를 상속받는 하위 인터페이스를 만들어서 새로운 연산을 추가하면 된다.

이로써 클라이언트는 기존 인터페이스가 필요한 경우에도 새로운 인터페이스를 사용할 수 있고, 기존 인터페이스에 따라 작성한 코드도 계속해서 사용 가능하다.

이러한 유연성에는 복잡도의 증가라는 비용이 따른다.

프레임워크는 새로운 인터페이스에 있는 연산을 호출할 때마다 명시적으로 타입 변환을 해줘야 한다.

```java
public interface Animal {
  void walk();
}

public interface Dog extends Animal {
  @Override
  void walk();

  void bark();
}

public static void main(String[] args) {
  Animal animal = new Dog() { ... };
  **if (animal instanceof Dog) {
    final Dog dog = (Dog) animal;**
    **dog.bark();**
  }
}
```

버전 인터페이스는 클라이언트 코드에 영향을 주지 않으면서 기존 인터페이스에 새로운 연산을 추가하고자 할 때 사용할 수 있는 합리적인 기법이다.

하지만, 자주 변경되는 추상화에는 사용되기 어렵다.

자주 변경되는 추상화를 깔끔하게 처리하고 싶다면 상위클래스를 사용하는 편이 낫다.

***상위 클래스***

클래스는 인터페이스보다 세부 사항을 나타낼 수 있으면서, 상위 클래스에 새로운 메소드를 추가해도 호환성에 문제가 발생하지 않는다.

하지만 인터페이스와 달리 클라이언트 클래스는 단 하나의 프레임워크 클래스만을 상속할 수 있다. ⇒ 자바에서는 다중 상속이 불가능하다.

클라이언트에게 공개되는 상위클래스의 세부 사항은 `Public` 및 `Protected` 메소드와 필드이다.

너무 많은 세부 사항을 공개한 경우 앞으로 설계 수정을 하는 데 있어 많은 제약이 따른다.

그러므로, 세부 사항을 줄여서 인터페이스에서 노출하는 정보 수준에 가깝게 해야한다.

프레임워크의 필드는 언제나 `Private` 이어야 한다.

만약 클라이언트가 필드 데이터에 접근해야 한다면 `Getter` 를 제공하라.

추상 클래스로 상위 클래스를 구현할 때, `abstract` 키워드를 메서드에 사용하면 클라이언트는 그것을 반드시 구현해야 하기 때문에
어떤 로직을 제공해야 하는지 알려줄 수 있다.

그러나 상위 클래스에 새로운 추상 메소드를 추가하면 클라이언트가 반드시 새로운 메소드를 구현해야 하는 호환성 문제가 발생한다.

만약 `final` 키워드를 클래스에서 사용하면 하위클래스를 생성할 수 없게 되어, 클라이언트는 인스턴스화나 설정 스타일 중
한 가지 방법으로만 프레임워크를 사용해야만 한다.

그러므로 프레임워크 개발자에게 상당한 이득을 가져오고 클라이언트에게 문제를 일으키지 않는 경우에만 `final` 을 쓰는 것을 권장한다.

여러 개의 패키지로 구성되는 프레임워크는 **"프레임워크 내에서는 보이지만 클라이언트에는 보이지 않는"** 가시성 수준을 필요로 할 수 있다.

이는 별도의 내부 패키지 경로를 만들어서 차이점을 전달할 수 있다.

예를 들어 `io.wisoft.datastructure` 와 별도로 `io.wisoft.datastructure.internal` 이라는 패키지를 만들 수 있다.

### 생성

프레임워크에서 어떤 구상 클래스를 사용하는 경우, 클라이언트는 어떻게 클래스를 인스턴스화할지 결정해야 한다.

인스턴스화 방법을 정할 때는 **일반성, 복잡도, 사용의 용이성, 발전의 용이성** 등을 모두 고려해서 균형 잡힌 결정을 해야 한다.

네 가지 스타일은 클라이언트 **생성 금지(no creation)**, **생성자(constructor)**, **공장 메소드(factory method)**, **공장 객체(factory object)**이다.

***생성 금지***

가장 단순하고 유용성이 떨어지는 옵션은 클라이언트가 프레임워크 객체를 직접 생성하는 것을 금지하는 것이다.

```java
package java.util;

public class Collections {

  private Collections() {
  }

	...

}
```

***생성자***

클라이언트가 생성자를 통해 객체를 생성하게 하는 것은 간단하지만, 이는 이후 프레임워크 수정에 상당한 제약을 가져온다.

생성자를 공개하는 것은 클래스 이름, 객체 생성에 필요한 파라미터, 클래스가 속한 패키지 등 반환되는 구상 클래스의 대부분의 요소를 수정하지 않겠다고 선언하는 것과 같다.

생성자를 통해 객체를 생성하는 것의 장점은 클라이언트 입장에서 볼 때 단순 명확하다는 것이다.

프레임워크에서 클래스의 패키지, 이름, 구상 클래스를 바꾸지 않아도 괜찮은 경우라면 생성자를 사용하는 것이 합리적인 선택일 것이다.

***정적 공장***

정적 공장(static factories)을 사용하면 클라이언트가 객체를 생성하는 복잡도가 상당히 증가하지만, 프레임워크 개발자는 미래의 설계 수정에 유연성을 갖게 된다.

하지만 생성 과정을 추상화할수록 코드를 읽으면서 어느 곳에서 객체가 생성되는지를 알기는 어려워진다.

공장 메소드의 다른 장점은 객체 생성 시의 변형을 클라이언트에게 좀더 명확히 전달할 수 있다는 것이다.

공장 메소드를 사용하면 메소드 이름을 통해 객체 생성에 어떤 변형을 가하는지 전달할 수 있다.

```java
List<Integer> integers = List.of(1, 2, 3);
```

***공장 객체***

정적 메소드를 호출하는 대신 공장 객체(factory obejct)에 메시지를 보내서 인스턴스를 생성하는 방법도 있다.

예를 들어 `CollectionFactory` 클래스가 존재한다면, `Collections.factory().createArraysList()` 와 같은 메소드 호출을 통해 리스트를 생성하는 것이
가능할 것이다.

이는 높은 유연성을 얻을 수 있지만, 코드를 읽기 어려워진다. 어떤 클래스가 생성되는지 알기 위해서는 코드 수행을 따라가야 하기 때문이다.

### 메소드

객체 생성과 더불어 메소드 역시 프레임워크의 사용과 수정에 영향을 미친다.

클라이언트가 문제를 해결할 수 있도록 하되 가급적 세부사항은 적게 노출해야 한다.

클라이언트가 내부 자료 구조에 의존하도록 하면 프레임워크를 수정하는 것은 무척 어려워진다.

그러므로 클라이언트가 내부 자료 구조에 접근하는 `Setter` 메서드를 제공하는 것이 아니라,
값을 설정해서 어떤 문제를 해결하려 하는지 파악한 뒤 클라이언트가 해결하려는 문제를 메소드 이름에 반영하는 것이 좋다.

예를 들어 프레임워크에 `setVisible(boolean)` 메서드가 있다고 가정해보자.

지금은 `Visible` 상태를 `true` , `false` 로 변경하고 있지만, 만약 비활성화 상태를 추가해야 한다면 메서드를 수정해야 한다.

그러므로 `setVisible(boolean)` 이 아닌 `visible()` 과 `invisible()` 메서드를 제공했으면, 상태가 추가되었을 때 `inactive()` 메소드를 추가해도 클라이언트 코드를 수정하지 않을 수 있다.

인터페이스에 기반한 추상화는 조금 다르다. `inactive()` 메소드를 인터페이스에 추가하면 기존 클라이언트의 구현이 동작하지 않게 된다.

그러므로 상태를 나타내는 열거 타입인 `State` 를 사용해서 `setVisible(State)` 메소드를 제공하라.

---
